# =============================================================================
# TEMPLATES GÉNÉRIQUES GITLAB CI/CD
# =============================================================================
# Description : Templates de base réutilisables pour tous les jobs
# Version     : 1.0.0
# Auteur      : Infrastructure Team
# =============================================================================

# -----------------------------------------------------------------------------
# INSTALLATION TERRAFORM OPTIMISÉE
# -----------------------------------------------------------------------------
# Template amélioré avec cache intelligent et gestion d'erreurs robuste
.install_terraform:
  before_script:
    # Diagnostic et préparation environnement
    - |
      echo "🔍 Diagnostic environnement d'exécution..."
      echo "Runner: ${CI_RUNNER_DESCRIPTION:-shared}"
      echo "Image: ${CI_JOB_IMAGE}"
      echo "Terraform version cible: ${TF_VERSION}"
      echo "Répertoire de travail: $(pwd)"
      
    # Installation des dépendances de base
    - echo "📦 Installation des dépendances système..."
    - apk add --no-cache curl unzip bash git openssh ca-certificates jq
    
    # Configuration du cache Terraform optimisé
    - |
      echo "🔧 Configuration du cache Terraform..."
      export TF_CACHE_DIR="${TF_CACHE_DIR:-/tmp/terraform-cache-${TF_VERSION}}"
      export TF_PLUGIN_CACHE_DIR="${TF_PLUGIN_CACHE_DIR:-$TF_CACHE_DIR/plugins}"
      mkdir -p "$TF_CACHE_DIR" "$TF_PLUGIN_CACHE_DIR"
      
    # Installation de Terraform avec retry et validation
    - |
      echo "📥 Installation de Terraform v${TF_VERSION}..."
      if [ ! -f "$TF_CACHE_DIR/terraform" ]; then
        max_retries=3
        retry_count=0
        
        while [ $retry_count -lt $max_retries ]; do
          if curl -SLO "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"; then
            unzip -q "terraform_${TF_VERSION}_linux_amd64.zip" -d "$TF_CACHE_DIR/"
            chmod +x "$TF_CACHE_DIR/terraform"
            rm -f "terraform_${TF_VERSION}_linux_amd64.zip"
            break
          else
            retry_count=$((retry_count + 1))
            echo "⚠️  Tentative $retry_count/$max_retries échouée. Nouvelle tentative..."
            sleep 2
          fi
        done
        
        if [ $retry_count -eq $max_retries ]; then
          echo "❌ Impossible de télécharger Terraform après $max_retries tentatives"
          exit 1
        fi
      fi
      
    # Installation et validation
    - cp "$TF_CACHE_DIR/terraform" /usr/local/bin/terraform
    - |
      if terraform version | grep -q "${TF_VERSION}"; then
        echo "✅ Terraform ${TF_VERSION} installé avec succès"
      else
        echo "❌ Version Terraform incorrecte"
        terraform version
        exit 1
      fi

# -----------------------------------------------------------------------------
# CONFIGURATION SSH SÉCURISÉE
# -----------------------------------------------------------------------------
# Template pour la configuration SSH avec gestion des clés et known_hosts
.setup_ssh:
  before_script:
    - echo "🔐 Configuration SSH sécurisée..."
    - apk add --no-cache git openssh-client
    
    # Configuration du répertoire SSH
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    
    # Configuration de la clé privée
    - |
      if [ -z "$SSH_PRIVATE_KEY" ]; then
        echo "❌ Variable SSH_PRIVATE_KEY manquante"
        exit 1
      fi
      
      # Support Ed25519 et RSA
      if echo "$SSH_PRIVATE_KEY" | grep -q "BEGIN OPENSSH PRIVATE KEY\|BEGIN.*ED25519"; then
        echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519
        chmod 600 ~/.ssh/id_ed25519
        ssh_key_path="~/.ssh/id_ed25519"
      else
        echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh_key_path="~/.ssh/id_rsa"
      fi
      
    # Configuration known_hosts pour éviter les prompts
    - |
      echo "📝 Configuration des known_hosts..."
      for host in github.com gitlab.com ${CUSTOM_SSH_HOSTS:-}; do
        if [ ! -z "$host" ]; then
          ssh-keyscan -H "$host" >> ~/.ssh/known_hosts 2>/dev/null || true
        fi
      done
      
    # Configuration SSH globale
    - |
      cat > ~/.ssh/config << EOF
      Host *
        StrictHostKeyChecking no
        UserKnownHostsFile ~/.ssh/known_hosts
        ServerAliveInterval 60
        ServerAliveCountMax 3
      EOF
      chmod 600 ~/.ssh/config
      
    - echo "✅ Configuration SSH terminée"

# -----------------------------------------------------------------------------
# BASE TERRAFORM
# -----------------------------------------------------------------------------
# Template de base pour tous les jobs Terraform avec configuration optimale
.terraform_base:
  image: alpine:latest
  extends: .install_terraform
  variables:
    GIT_DEPTH: 1
    TF_IN_AUTOMATION: "true"
    TF_INPUT: "false"
    TF_CLI_ARGS: "-no-color"
  cache:
    key: "terraform-${CI_COMMIT_REF_SLUG}-${ENV:-global}"
    paths:
      - ${TF_ROOT}/${ENV}/.terraform
      - ${TF_ROOT}/${ENV}/.terraform.lock.hcl
      - /tmp/terraform-cache-${TF_VERSION}
    policy: pull-push
  artifacts:
    when: always
    expire_in: 1 week
    paths:
      - ${TF_ROOT}/${ENV}/tfplan
      - ${TF_ROOT}/${ENV}/*.tfstate
      - ${TF_ROOT}/${ENV}/*.tfstate.backup
      - ${TF_ROOT}/${ENV}/terraform_outputs.json
    reports:
      terraform: ${TF_ROOT}/${ENV}/tfplan.json
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
  interruptible: true

# -----------------------------------------------------------------------------
# BASE ANSIBLE
# -----------------------------------------------------------------------------
# Template de base pour tous les jobs Ansible avec best practices
.ansible_base:
  image: cytopia/ansible:latest-tools
  variables:
    ANSIBLE_HOST_KEY_CHECKING: "False"
    ANSIBLE_FORCE_COLOR: "True"
    ANSIBLE_STDOUT_CALLBACK: "yaml"
    ANSIBLE_LOAD_CALLBACK_PLUGINS: "True"
    ANSIBLE_CALLBACKS_ENABLED: "profile_tasks,timer"
  before_script:
    - echo "🔧 Préparation environnement Ansible..."
    - ansible --version
    - |
      # Configuration des collections Ansible si nécessaire
      if [ -f "ansible/requirements.yml" ]; then
        echo "📦 Installation des collections Ansible..."
        ansible-galaxy collection install -r ansible/requirements.yml
      fi
  cache:
    key: "ansible-${CI_COMMIT_REF_SLUG}"
    paths:
      - ~/.ansible
    policy: pull-push
  artifacts:
    when: always
    expire_in: 1 day
    paths:
      - ansible/logs/
    reports:
      junit: ansible/logs/junit.xml
  retry:
    max: 1
    when:
      - runner_system_failure

# -----------------------------------------------------------------------------
# BASE PYTHON
# -----------------------------------------------------------------------------
# Template pour les jobs nécessitant Python (sync, scripts)
.python_base:
  image: python:3.11-alpine
  variables:
    PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  before_script:
    - echo "🐍 Configuration environnement Python..."
    - python --version
    - pip --version
    - |
      # Installation des dépendances si requirements.txt existe
      if [ -f "requirements.txt" ]; then
        echo "📦 Installation des dépendances Python..."
        pip install --upgrade pip
        pip install -r requirements.txt
      fi
  cache:
    key: "python-${CI_COMMIT_REF_SLUG}"
    paths:
      - .cache/pip
    policy: pull-push

# -----------------------------------------------------------------------------
# BASE DOCKER
# -----------------------------------------------------------------------------
# Template pour les jobs nécessitant Docker
.docker_base:
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_DRIVER: overlay2
  before_script:
    - echo "🐳 Configuration environnement Docker..."
    - docker version
    - docker info

# -----------------------------------------------------------------------------
# ENVIRONNEMENTS SPÉCIFIQUES
# -----------------------------------------------------------------------------
# Templates pour configuration par environnement

.dev_environment:
  variables:
    ENV: dev
    DEPLOYMENT_TYPE: development
    LOG_LEVEL: debug
    ENABLE_DEBUG: "true"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_BRANCH =~ /^feature\/.*$/'
  environment:
    name: development
    action: start

.prod_environment:
  variables:
    ENV: prod
    DEPLOYMENT_TYPE: production
    LOG_LEVEL: info
    ENABLE_DEBUG: "false"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
  before_script:
    - |
      echo "⚠️  DÉPLOIEMENT EN PRODUCTION ⚠️"
      echo "Utilisateur: ${GITLAB_USER_NAME}"
      echo "Branche: ${CI_COMMIT_BRANCH}"
      echo "Commit: ${CI_COMMIT_SHORT_SHA}"
  environment:
    name: production
    action: start
    on_stop: stop_production

# -----------------------------------------------------------------------------
# UTILITAIRES
# -----------------------------------------------------------------------------
# Templates pour fonctionnalités communes

.with_artifacts_from_previous:
  needs:
    - job: $PREVIOUS_JOB
      artifacts: true

.performance_tracking:
  before_script:
    - export JOB_START_TIME=$(date +%s)
  after_script:
    - |
      if [ ! -z "$JOB_START_TIME" ]; then
        JOB_END_TIME=$(date +%s)
        JOB_DURATION=$((JOB_END_TIME - JOB_START_TIME))
        echo "⏱️  Durée du job: ${JOB_DURATION}s"
      fi

.with_notification:
  after_script:
    - |
      # Notification simple (à personnaliser selon les besoins)
      echo "📬 Job ${CI_JOB_NAME} terminé avec statut: ${CI_JOB_STATUS:-unknown}"