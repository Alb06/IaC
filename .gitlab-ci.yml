# =============================================================================
# PIPELINE GITLAB CI/CD - INFRASTRUCTURE AS CODE
# =============================================================================
# Description : Pipeline automatis√© pour le d√©ploiement IaC
# Utilise les variables centralis√©es du module globals
# Version : 2.0.0 - Gestion centralis√©e des versions Terraform
# =============================================================================

stages:
  - validate
  - plan
  - apply
  - deploy
  - sync
  - cleanup

variables:
  TF_ROOT: ${CI_PROJECT_DIR}/terraform/environments
  # Versions r√©cup√©r√©es dynamiquement depuis les outputs Terraform
  TF_VERSION: ""
  GIT_DEPTH: 0
  # Configuration Ansible
  ANSIBLE_HOST_KEY_CHECKING: "False"
  ANSIBLE_FORCE_COLOR: "True"
  # Configuration s√©curit√©
  DOCKER_TLS_CERTDIR: "/certs"
  # Optimisation pour shared runners
  DOCKER_DRIVER: overlay2
  FF_USE_FASTZIP: "true"
  ARTIFACT_COMPRESSION_LEVEL: "fast"
  CACHE_COMPRESSION_LEVEL: "fast"

# Cache optimis√© pour shared runners
cache:
  key: 
    files:
      - terraform/**/*.tf
      - .gitlab-ci.yml
  paths:
    - .terraform
    - .terraform.lock.hcl
    - ${TF_ROOT}/**/.terraform
  policy: pull-push
  when: always

# =============================================================================
# TEMPLATES R√âUTILISABLES
# =============================================================================

# .install_terraform: &install_terraform
#   before_script:
#     - echo "üîß Installation de Terraform v${TF_VERSION}..."
#     - apk add --no-cache curl unzip bash git openssh
#     - mkdir -p /tmp/terraform-cache
#     - |
#       if [ ! -f "/tmp/terraform-cache/terraform_${TF_VERSION}" ]; then
#         echo "üì• T√©l√©chargement de Terraform..."
#         curl -SLO "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
#         unzip "terraform_${TF_VERSION}_linux_amd64.zip" -d /tmp/terraform-cache/
#         mv /tmp/terraform-cache/terraform "/tmp/terraform-cache/terraform_${TF_VERSION}"
#       fi
#     - cp "/tmp/terraform-cache/terraform_${TF_VERSION}" /usr/local/bin/terraform
#     - chmod +x /usr/local/bin/terraform
#     - terraform --version
#     - echo "‚úÖ Terraform install√© avec succ√®s"

.install_terraform: &install_terraform
  before_script:
    - export TF_VERSION=$(terraform output -raw versions | jq -r '.terraform') 
    - echo "üîß Installation de Terraform v${TF_VERSION}..."
    - apk add --no-cache curl unzip bash git openssh ca-certificates
    
    # Cache plus agressif pour shared runners
    - export TF_CACHE_DIR="/tmp/terraform-cache-${TF_VERSION}"
    - mkdir -p "$TF_CACHE_DIR"
    
    - |
      if [ ! -f "$TF_CACHE_DIR/terraform" ]; then
        echo "üì• T√©l√©chargement de Terraform..."
        curl -SLO "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
        unzip "terraform_${TF_VERSION}_linux_amd64.zip" -d "$TF_CACHE_DIR/"
        chmod +x "$TF_CACHE_DIR/terraform"
      fi
    
    - cp "$TF_CACHE_DIR/terraform" /usr/local/bin/terraform
    - terraform --version
    - echo "‚úÖ Terraform install√© avec succ√®s sur shared runner"

.setup_ssh: &setup_ssh
  - echo "üîê Configuration SSH..."
  - apk add --no-cache git openssh
  - mkdir -p ~/.ssh
  - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519
  - chmod 600 ~/.ssh/id_ed25519
  - ssh-keyscan github.com >> ~/.ssh/known_hosts

# =============================================================================
# VALIDATION ET PLANIFICATION
# =============================================================================

# üÜï VALIDATION SP√âCIFIQUE DES VERSIONS TERRAFORM
validate_versions:
  stage: validate
  image: alpine:latest
  <<: *install_terraform
  script:
    - echo "üîç Validation des contraintes de versions Terraform..."
    - apk add --no-cache jq
    
    # V√©rification de l'existence des fichiers versions.tf
    - |
      echo "üìã V√©rification de la pr√©sence des fichiers versions.tf..."
      
      required_files=(
        "terraform/globals/versions.tf"
        "terraform/environments/dev/versions.tf"
        "terraform/environments/prod/versions.tf"
      )
      
      for file in "${required_files[@]}"; do
        if [ ! -f "$file" ]; then
          echo "‚ùå Fichier manquant: $file"
          exit 1
        else
          echo "‚úÖ Fichier trouv√©: $file"
        fi
      done
    
    # V√©rification du formatage des fichiers versions.tf
    - |
      echo "üìã Validation du formatage des fichiers versions.tf..."
      for versions_file in $(find terraform/ -name "versions.tf"); do
        echo "üîß Formatage: $versions_file"
        terraform fmt -check=true -diff=true "$versions_file"
        if [ $? -ne 0 ]; then
          echo "‚ùå Fichier mal format√©: $versions_file"
          echo "üí° Ex√©cutez 'terraform fmt $versions_file' pour corriger"
          exit 1
        fi
      done
      echo "‚úÖ Tous les fichiers versions.tf sont correctement format√©s"
    
    # Validation syntaxique du module globals avec contraintes
    - |
      echo "üìã Validation syntaxique du module globals..."
      cd terraform/globals
      terraform init -backend=false
      terraform validate
      if [ $? -eq 0 ]; then
        echo "‚úÖ Module globals valid√© syntaxiquement"
      else
        echo "‚ùå Erreur de syntaxe dans le module globals"
        exit 1
      fi
      cd ../../
    
    # Validation de la coh√©rence des contraintes entre environnements
    - |
      echo "üìã V√©rification de la coh√©rence des contraintes entre environnements..."
      
      # Extraction des versions Terraform des environnements
      dev_tf_version=$(grep -A 1 "required_version" terraform/environments/dev/versions.tf | tail -1 | sed 's/.*= *"//; s/".*//')
      prod_tf_version=$(grep -A 1 "required_version" terraform/environments/prod/versions.tf | tail -1 | sed 's/.*= *"//; s/".*//')
      
      echo "Dev Terraform version: $dev_tf_version"
      echo "Prod Terraform version: $prod_tf_version"
      
      if [ "$dev_tf_version" != "$prod_tf_version" ]; then
        echo "‚ùå ERREUR: Contraintes Terraform diff√©rentes entre dev et prod"
        echo "   Dev:  $dev_tf_version"
        echo "   Prod: $prod_tf_version"
        exit 1
      fi
      
      # Validation que les contraintes respectent la version minimale
      if [[ "$dev_tf_version" == *"1.12.1"* ]]; then
        echo "‚úÖ Contraintes respectent la version minimale 1.12.1"
      else
        echo "‚ùå Contraintes ne respectent pas la version minimale 1.12.1"
        exit 1
      fi
      
      echo "‚úÖ Contraintes coh√©rentes entre tous les environnements"
    
    # Test d'application des contraintes sur les environnements
    - |
      echo "üìã Test d'application des contraintes sur les environnements..."
      
      for env in dev prod; do
        echo "üß™ Test environnement: $env"
        cd "terraform/environments/$env"
        
        # Init et validation avec les nouvelles contraintes
        terraform init -backend=false
        terraform validate
        
        if [ $? -eq 0 ]; then
          echo "‚úÖ Environnement $env compatible avec les contraintes"
        else
          echo "‚ùå Environnement $env incompatible avec les contraintes"
          exit 1
        fi
        
        cd ../../../
      done
    
    # G√©n√©ration d'un rapport de validation
    - |
      echo "üìä G√©n√©ration du rapport de validation des versions..."
      cat > version_validation_report.json << EOF
      {
        "validation_date": "$(date -Iseconds)",
        "terraform_version_used": "${TF_VERSION}",
        "validation_status": "SUCCESS",
        "files_validated": [
          "terraform/globals/versions.tf",
          "terraform/environments/dev/versions.tf",
          "terraform/environments/prod/versions.tf"
        ],
        "constraints_verified": {
          "terraform_version": ">= 1.12.1, < 2.0.0",
          "provider_local": "~> 2.5",
          "provider_null": "~> 3.2"
        },
        "environments_tested": ["dev", "prod"],
        "consistency_check": "PASSED"
      }
      EOF
      
      echo "üìÑ Rapport de validation g√©n√©r√©:"
      cat version_validation_report.json | jq '.'
    
    - echo "üéâ Validation des versions Terraform termin√©e avec succ√®s"
  
  artifacts:
    paths:
      - version_validation_report.json
    expire_in: 1 week
    reports:
      junit: version_validation_report.json
  
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
  # tags:
  #   - terraform

# Validation globale du code Terraform (mise √† jour)
validate:
  stage: validate
  image: alpine:latest
  timeout: 3m
  <<: *install_terraform
  script:
    - echo "üîç Validation globale du code Terraform..."
    - cd ${TF_ROOT}
    
    # Validation du module globals (versions.tf + main.tf)
    - echo "üìã Validation compl√®te du module globals..."
    - cd ../globals && terraform init -backend=false && terraform validate
    - cd ../environments
    
    # Validation de tous les environnements avec leurs versions.tf
    - |
      for env in dev prod; do
        echo "üìã Validation environnement: $env"
        if [ ! -d "$env" ]; then
          echo "‚ùå Dossier $env inexistant"
          exit 1
        fi
        cd "$env"
        
        # V√©rification de la pr√©sence de versions.tf
        if [ ! -f "versions.tf" ]; then
          echo "‚ùå Fichier versions.tf manquant dans $env"
          exit 1
        fi
        
        terraform init -backend=false
        terraform validate
        if [ $? -eq 0 ]; then
          echo "‚úÖ $env valid√© avec succ√®s (main.tf + versions.tf)"
        else
          echo "‚ùå Erreur de validation pour $env"
          exit 1
        fi
        cd ..
      done
    - echo "üéâ Validation globale r√©ussie avec la nouvelle structure versions"
  
  dependencies:
    - validate_versions
  
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
  # tags:
  #   - terraform

# Planification pour l'environnement dev (VERSION CORRIG√âE)
plan_dev:
  stage: plan
  image: alpine:latest
  timeout: 3m  
  <<: *install_terraform
  variables:
    ENV: dev
  script:
    - echo "üìã Planification Terraform pour $ENV avec contraintes centralis√©es..."
    - cd ${TF_ROOT}/${ENV}
    - terraform init
    
    # V√©rification des contraintes appliqu√©es
    - |
      echo "üîç V√©rification des contraintes Terraform appliqu√©es..."
      terraform version
      echo "Contraintes du fichier versions.tf:"
      cat versions.tf | grep -E "(required_version|version)"
    
    # R√©cup√©ration des variables depuis le module globals et planification
    - echo "üîç R√©cup√©ration des variables centralis√©es..."
    - |
      # CORRECTION: Gestion propre des exit codes terraform plan
      set +e  # D√©sactive l'arr√™t automatique sur erreur
      terraform plan -out=tfplan -detailed-exitcode
      plan_exit_code=$?
      set -e  # R√©active l'arr√™t automatique sur erreur
      
      echo "Terraform plan exit code: $plan_exit_code"
      
      case $plan_exit_code in
        0)
          echo "‚úÖ Aucun changement d√©tect√©"
          echo "PLAN_STATUS=no_changes" > ./plan_status.env
          plan_result="success"
          ;;
        1)
          echo "‚ùå Erreur lors de la planification"
          echo "PLAN_STATUS=error" > ./plan_status.env
          exit 1
          ;;
        2)
          echo "üìù Changements d√©tect√©s, plan g√©n√©r√©"
          echo "PLAN_STATUS=changes_detected" > ./plan_status.env
          plan_result="success"
          ;;
        *)
          echo "‚ùå Code de sortie inattendu: $plan_exit_code"
          echo "PLAN_STATUS=unknown_error" > ./plan_status.env
          exit 1
          ;;
      esac
      
      echo "Plan result: $plan_result"
      echo "Created plan_status.env with content:"
      cat ./plan_status.env
    
    # CORRECTION: Gestion de l'output pour √©viter SIGPIPE (exit code 141)
    - echo "üìä G√©n√©ration du r√©sum√© du plan..."
    - |
      # Limiter l'output pour √©viter les pipes cass√©s
      terraform show -no-color tfplan > plan_output.txt 2>&1 || true
      
      # Affichage du r√©sum√© (limit√©)
      echo "=== R√âSUM√â DU PLAN TERRAFORM (avec versions centralis√©es) ==="
      echo "Nombre de lignes du plan: $(wc -l < plan_output.txt)"
      
      # Afficher seulement le r√©sum√© des changements
      grep -E "(Plan:|No changes)" plan_output.txt || echo "Plan g√©n√©r√©"
      
      # Afficher les premi√®res ressources pour validation
      echo ""
      echo "=== APER√áU DES CHANGEMENTS ==="
      head -30 plan_output.txt
      echo ""
      echo "... (plan complet sauvegard√© dans plan_output.txt)"
    
    - echo "‚úÖ Planification $ENV termin√©e avec succ√®s"
    
  artifacts:
    paths:
      - ${TF_ROOT}/${ENV}/tfplan
      - ${TF_ROOT}/${ENV}/plan_status.env
      - ${TF_ROOT}/${ENV}/plan_output.txt
    expire_in: 1 week
    reports:
      dotenv: ${TF_ROOT}/${ENV}/plan_status.env
  
  dependencies:
    - validate_versions
    - validate
  
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
  # tags:
  #   - terraform

# Planification pour l'environnement prod (VERSION CORRIG√âE)
plan_prod:
  stage: plan
  image: alpine:latest
  timeout: 3m
  <<: *install_terraform
  variables:
    ENV: prod
  script:
    - echo "üìã Planification Terraform pour $ENV avec contraintes centralis√©es..."
    - cd ${TF_ROOT}/${ENV}
    - terraform init
    
    # Validation suppl√©mentaire pour la production
    - echo "üîê Validations de s√©curit√© production..."
    - |
      # V√©rification des variables critiques
      if [ -z "$SSH_PRIVATE_KEY" ]; then
        echo "‚ùå SSH_PRIVATE_KEY manquante pour la production"
        exit 1
      fi
      
      # V√©rification des contraintes appliqu√©es en production
      echo "üîç V√©rification des contraintes Terraform production..."
      terraform version
      echo "Contraintes du fichier versions.tf:"
      cat versions.tf | grep -E "(required_version|version)"
      
      # CORRECTION: Gestion propre des exit codes terraform plan
      set +e  # D√©sactive l'arr√™t automatique sur erreur
      terraform plan -out=tfplan -detailed-exitcode
      plan_exit_code=$?
      set -e  # R√©active l'arr√™t automatique sur erreur
      
      echo "Terraform plan exit code: $plan_exit_code"
      
      case $plan_exit_code in
        0)
          echo "‚úÖ Aucun changement d√©tect√© en production"
          echo "PLAN_STATUS=no_changes" > ./plan_status.env
          plan_result="success"
          ;;
        1)
          echo "‚ùå Erreur lors de la planification production"
          echo "PLAN_STATUS=error" > ./plan_status.env
          exit 1
          ;;
        2)
          echo "‚ö†Ô∏è  ATTENTION: Changements d√©tect√©s en PRODUCTION"
          echo "PLAN_STATUS=changes_detected" > ./plan_status.env
          echo "Plan d√©taill√© sera affich√© dans le r√©sum√© ci-dessous"
          plan_result="success"
          ;;
        *)
          echo "‚ùå Code de sortie inattendu: $plan_exit_code"
          echo "PLAN_STATUS=unknown_error" > ./plan_status.env
          exit 1
          ;;
      esac
      
      echo "Plan result: $plan_result"
      echo "Created plan_status.env with content:"
      cat ./plan_status.env
    
    # CORRECTION: Gestion de l'output pour √©viter SIGPIPE (exit code 141)
    - echo "üìä G√©n√©ration du r√©sum√© du plan production..."
    - |
      # Limiter l'output pour √©viter les pipes cass√©s
      terraform show -no-color tfplan > plan_output.txt 2>&1 || true
      
      # Affichage du r√©sum√© (limit√©)
      echo "=== R√âSUM√â DU PLAN TERRAFORM PRODUCTION (avec versions centralis√©es) ==="
      echo "Nombre de lignes du plan: $(wc -l < plan_output.txt)"
      
      # Afficher seulement le r√©sum√© des changements
      grep -E "(Plan:|No changes)" plan_output.txt || echo "Plan g√©n√©r√©"
      
      # Afficher les premi√®res ressources pour validation
      echo ""
      echo "=== APER√áU DES CHANGEMENTS PRODUCTION ==="
      head -30 plan_output.txt
      echo ""
      echo "... (plan complet sauvegard√© dans plan_output.txt)"
    
    - echo "‚úÖ Planification $ENV termin√©e avec succ√®s"
  
  artifacts:
    paths:
      - ${TF_ROOT}/${ENV}/tfplan
      - ${TF_ROOT}/${ENV}/plan_status.env
      - ${TF_ROOT}/${ENV}/plan_output.txt
    expire_in: 1 week
    reports:
      dotenv: ${TF_ROOT}/${ENV}/plan_status.env
  
  dependencies:
    - validate_versions
    - validate
  
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  # tags:
  #   - terraform

# =============================================================================
# APPLICATION DES CHANGEMENTS
# =============================================================================

# Application en environnement dev
apply_dev:
  stage: apply
  image: alpine:latest
  timeout: 3m  
  <<: *install_terraform
  variables:
    ENV: dev
  script:
    - echo "üöÄ Application Terraform pour $ENV avec contraintes centralis√©es..."
    - cd ${TF_ROOT}/${ENV}
    - terraform init
    
    # V√©rification de l'existence du plan
    - |
      if [ ! -f "tfplan" ]; then
        echo "‚ùå Fichier plan non trouv√©"
        exit 1
      fi
    
    # Application du plan
    - terraform apply -auto-approve tfplan
    
    # R√©cup√©ration des outputs pour validation
    - echo "üìä R√©cup√©ration des outputs..."
    - terraform output -json > terraform_outputs.json
    
    # üÜï Validation des contraintes appliqu√©es
    - |
      echo "üîç Validation des contraintes de versions appliqu√©es..."
      if command -v jq >/dev/null 2>&1; then
        apk add --no-cache jq
        terraform_constraints=$(terraform output -json terraform_constraints 2>/dev/null || echo "{}")
        echo "Contraintes appliqu√©es:"
        echo "$terraform_constraints" | jq '.' || echo "Contraintes non disponibles dans les outputs"
      fi
    
    # Validation des inventaires Ansible g√©n√©r√©s
    - echo "üîç Validation des inventaires Ansible..."
    - |
      inventory_file="../../../ansible/inventory/${ENV}"
      if [ -f "$inventory_file" ]; then
        echo "‚úÖ Inventaire g√©n√©r√©: $inventory_file"
        head -20 "$inventory_file"
      else
        echo "‚ùå Inventaire non g√©n√©r√©"
        exit 1
      fi
  
  artifacts:
    paths:
      - ${TF_ROOT}/${ENV}/terraform_outputs.json
      - ${TF_ROOT}/${ENV}/version-constraints.json
      - ansible/inventory/${ENV}
    expire_in: 1 day
  
  dependencies:
    - plan_dev
  
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
      allow_failure: false
  # tags:
  #   - terraform

# Application en environnement prod (protection renforc√©e)
apply_prod:
  stage: apply
  image: alpine:latest
  timeout: 3m
  <<: *install_terraform
  variables:
    ENV: prod
  script:
    - echo "üöÄ Application Terraform pour PRODUCTION avec contraintes centralis√©es..."
    - echo "‚ö†Ô∏è  ATTENTION D√©ploiement en environnement de PRODUCTION"
    
    - cd ${TF_ROOT}/${ENV}
    - terraform init
    
    # V√©rifications de s√©curit√© renforc√©es
    - |
      echo "üîê V√©rifications de s√©curit√© production..."
      
      if [ ! -f "tfplan" ]; then
        echo "‚ùå Fichier plan non trouv√©"
        exit 1
      fi
      
      # V√©rification de la branche
      if [ "$CI_COMMIT_BRANCH" != "main" ]; then
        echo "‚ùå D√©ploiement production autoris√© uniquement depuis main"
        exit 1
      fi
      
      # V√©rification des contraintes de versions avant application
      echo "üîç V√©rification finale des contraintes Terraform..."
      terraform version
      cat versions.tf | grep -E "(required_version|version)"
      
      # V√©rification de l'auteur (optionnel)
      echo "üë§ D√©ploiement par: $GITLAB_USER_NAME ($GITLAB_USER_EMAIL)"
    
    # Sauvegarde avant application
    - echo "üíæ Sauvegarde de l'√©tat actuel..."
    - cp terraform.tfstate "terraform.tfstate.backup.$(date +%Y%m%d_%H%M%S)" 2>/dev/null || true
    
    # Application du plan
    - terraform apply -auto-approve tfplan
    
    # Validation post-d√©ploiement
    - echo "‚úÖ Validation post-d√©ploiement..."
    - terraform output -json > terraform_outputs.json
    
    # üÜï Validation des contraintes en production
    - |
      echo "üîç Validation des contraintes production..."
      apk add --no-cache jq
      if [ -f "version-constraints.json" ]; then
        echo "üìÑ Contraintes production appliqu√©es:"
        cat version-constraints.json | jq '.production_specific // "Aucune sp√©cificit√© production"'
      fi
    
    # Test de connectivit√© (si possible)
    - |
      server_ip=$(terraform output -raw server_config | jq -r '.ip' 2>/dev/null || echo "")
      if [ ! -z "$server_ip" ]; then
        echo "üåê Test de connectivit√© vers $server_ip..."
        ping -c 3 "$server_ip" || echo "‚ö†Ô∏è  Serveur non accessible via ping"
      fi
  
  artifacts:
    paths:
      - ${TF_ROOT}/${ENV}/terraform_outputs.json
      - ${TF_ROOT}/${ENV}/terraform.tfstate.backup.*
      - ${TF_ROOT}/${ENV}/version-constraints.json
      - ansible/inventory/${ENV}
    expire_in: 7 days
  
  dependencies:
    - plan_prod
  
  environment:
    name: production
    action: start
  
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
      allow_failure: false
  # tags:
  #   - terraform

# =============================================================================
# D√âPLOIEMENT ANSIBLE
# =============================================================================

# D√©ploiement Ansible dev
ansible_dev:
  stage: deploy
  image: cytopia/ansible:latest
  variables:
    ENV: dev
  before_script:
    - echo "üîß Pr√©paration Ansible pour $ENV..."
    - apk add --no-cache jq
  script:
    - cd ${CI_PROJECT_DIR}/ansible
    
    # V√©rification de l'inventaire g√©n√©r√©
    - |
      inventory_file="inventory/${ENV}"
      if [ ! -f "$inventory_file" ]; then
        echo "‚ùå Inventaire $inventory_file non trouv√©"
        echo "Contenu du dossier inventory:"
        ls -la inventory/
        exit 1
      fi
      
      echo "‚úÖ Inventaire trouv√©: $inventory_file"
      echo "Contenu de l'inventaire:"
      cat "$inventory_file"
    
    # Test de connectivit√© Ansible
    - echo "üîç Test de connectivit√© Ansible..."
    - ansible all -i "inventory/${ENV}" -m ping || echo "‚ö†Ô∏è  Test ping √©chou√©"
    
    # Ex√©cution du playbook (si existe)
    - |
      if [ -f "playbooks/setup.yml" ]; then
        echo "üöÄ Ex√©cution du playbook setup..."
        ansible-playbook -i "inventory/${ENV}" playbooks/setup.yml --check --diff
      else
        echo "‚ÑπÔ∏è  Aucun playbook setup.yml trouv√©"
      fi
  
  dependencies:
    - apply_dev
  
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
  tags:
    - ansible

# =============================================================================
# SYNCHRONISATION ET NETTOYAGE
# =============================================================================

# Synchronisation vers GitHub
mirror_to_github:
  stage: sync
  image: alpine:latest
  timeout: 3m
  before_script:
    - *setup_ssh
  script:
    - echo "üîÑ Synchronisation vers GitHub..."
    - git remote add mirror git@github.com:Alb06/IaC.git || true
    - git push mirror HEAD:main --force
    - echo "‚úÖ Synchronisation termin√©e"
  needs: []
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
  # tags:
  #   - terraform

# Synchronisation des issues
sync_issues_to_github:
  stage: sync
  image: python:3.11
  timeout: 3m
  before_script:
    - pip install requests
  script:
    - echo "üîÑ Synchronisation des issues GitLab ‚Üí GitHub..."
    - python scripts/ci-cd/sync_issues.py
  needs: []
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
  # tags:
  #   - terraform

# Nettoyage des ressources temporaires (mis √† jour)
cleanup:
  stage: cleanup
  image: alpine:latest
  timeout: 3m
  script:
    - echo "üßπ Nettoyage des ressources temporaires..."
    - |
      # Nettoyage des anciens plans
      find ${TF_ROOT} -name "tfplan" -mtime +7 -delete || true
      find ${TF_ROOT} -name "*.backup.*" -mtime +30 -delete || true
      
      # üÜï Nettoyage des anciens rapports de validation
      find . -name "version_validation_report.json" -mtime +7 -delete || true
      find ${TF_ROOT} -name "version-constraints.json" -mtime +30 -delete || true
      
      # Nettoyage des logs
      find /tmp -name "*.log" -mtime +1 -delete || true
      
      echo "‚úÖ Nettoyage termin√© (incluant fichiers de versions)"
  
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
  # tags:
  #   - terraform