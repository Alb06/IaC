stages:
  - validate
  - plan
  - apply
  - deploy
  - cleanup

variables:
  TF_ROOT: ${CI_PROJECT_DIR}/terraform/environments
  TF_VERSION: 1.12.1
  GIT_DEPTH: 0

# Cache des plugins Terraform
cache:
  paths:
    - .terraform

# Installation manuelle de Terraform
.install_terraform: &install_terraform
  before_script:
    - apk add --no-cache curl unzip bash
    - curl -SLO "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
    - unzip "terraform_${TF_VERSION}_linux_amd64.zip" -d /usr/local/bin/
    - chmod +x /usr/local/bin/terraform
    - terraform --version

# Validation du code Terraform
validate:
  stage: validate
  image: alpine:latest
  <<: *install_terraform
  script:
    - cd ${TF_ROOT}
    - |
      if [ ! -d "${ENV}" ]; then
        echo "Erreur: Le dossier ${ENV} n'existe pas dans ${TF_ROOT}"
        ls -la
        exit 1
      fi
    - find . -type f -name "*.tf" -exec dirname {} \; | sort -u | while read m; do (cd "$m" && terraform init -backend=false && terraform validate); done
  variables:
    ENV: dev
  tags:
    - terraform

# Planification des changements Terraform
plan:
  stage: plan
  image: alpine:latest
  <<: *install_terraform
  script:
    - cd ${TF_ROOT}/${ENV}
    - terraform init
    - terraform plan -out=tfplan
  variables:
    ENV: dev
  artifacts:
    paths:
      - ${TF_ROOT}/${ENV}/tfplan
    expire_in: 1 week
  tags:
    - terraform
  only:
    - merge_requests

# Application des changements Terraform
apply:
  stage: apply
  image: alpine:latest
  <<: *install_terraform
  script:
    - cd ${TF_ROOT}/${ENV}
    - terraform init
    - terraform apply -auto-approve tfplan
  variables:
    ENV: dev
  dependencies:
    - plan
  tags:
    - terraform
  only:
    - main
  when: manual

# Déploiement Ansible
ansible:
  stage: apply
  image: cytopia/ansible:latest
  script:
    - cd ${CI_PROJECT_DIR}/ansible
    - ansible-playbook -i inventory/dev playbooks/setup.yml
  tags:
    - ansible
  only:
    - main
  when: manual

# Déploiement Kubernetes avec Helm
kubernetes:
  stage: apply
  image: dtzar/helm-kubectl:latest
  script:
    - cd ${CI_PROJECT_DIR}/kubernetes/helm-charts
    - helm upgrade --install my-app ./my-app --namespace default
  tags:
    - kubernetes
  only:
    - main
  when: manual

# Synchronisation de la branche avec GitHub
mirror_to_github:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache git openssh
  script:
    # Configuration SSH
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519
    - chmod 600 ~/.ssh/id_ed25519
    - ssh-keyscan github.com >> ~/.ssh/known_hosts
    # Configuration du remote
    - git remote add mirror git@github.com:Alb06/IaC.git || true
    # Pousser le commit courant vers la branche main de GitHub
    - git push mirror HEAD:main --force
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
  tags:
    - terraform

# Synchronisation de l'état des taches avec GitHub
sync_issues_to_github:
  stage: deploy
  image: python:3.11
  before_script:
    - pip install requests
  script:
    - python scripts/ci-cd/sync_issues.py
  only:
    - main

# Nettoyage (optionnel)
cleanup:
  stage: cleanup
  image: alpine:latest
  script:
    - echo "Nettoyage des ressources temporaires..."
  tags:
    - terraform
  when: manual