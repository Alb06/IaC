# =============================================================================
# PIPELINE GITLAB CI/CD - INFRASTRUCTURE AS CODE (VERSION MODULAIRE)
# =============================================================================
# Description : Pipeline orchestrateur utilisant une architecture modulaire
# Version     : 3.0.0 - Modularisé et optimisé
# Migration   : Depuis pipeline monolithique v2.0.0
# Auteur      : Infrastructure Team
# =============================================================================

# 📋 INCLUSION DES MODULES SPÉCIALISÉS
include:
  - local: '.gitlab/ci/includes/variables.yml'
  - local: '.gitlab/ci/includes/templates.yml'
  - local: '.gitlab/ci/includes/terraform.yml'
  - local: '.gitlab/ci/includes/ansible.yml'
  - local: '.gitlab/ci/includes/sync.yml'
  - local: '.gitlab/ci/includes/cleanup.yml'

# 🔄 STAGES DU PIPELINE
stages:
  - validate     # Validation syntaxique et versions
  - plan         # Planification des changements
  - apply        # Application infrastructure
  - deploy       # Déploiement applicatif
  - sync         # Synchronisation externes
  - cleanup      # Nettoyage ressources

# =============================================================================
# 📊 MÉTRIQUES ET MONITORING DU PIPELINE
# =============================================================================

# Job de monitoring des performances du pipeline
pipeline_metrics:
  stage: cleanup
  image: alpine:latest
  script:
    - echo "📊 Métriques du pipeline modulaire:"
    - echo "  - Durée totale = $(($(date +%s) - $CI_PIPELINE_CREATED_AT))"
    - echo "  - Nombre de jobs = $(echo $CI_JOB_NAME | wc -w)"
    - echo "  - Branche = $CI_COMMIT_BRANCH"
    - echo "  - Version = 3.0.0 (modulaire)"
    - |
      if [ -f ".gitlab-ci.yml.backup" ]; then
        old_lines=$(wc -l < .gitlab-ci.yml.backup)
        new_lines=$(wc -l < .gitlab-ci.yml)
        reduction=$((($old_lines - $new_lines) * 100 / $old_lines))
        echo "  - Réduction code: ${reduction}% (${old_lines} → ${new_lines} lignes)"
      fi
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
  allow_failure: true

# =============================================================================
# 🚨 CONFIGURATION DE SÉCURITÉ GLOBALE
# =============================================================================

# Variables de sécurité héritées par tous les jobs
# (Les autres variables sont dans variables.yml)
variables:
  # Sécurité pipeline
  GIT_STRATEGY: clone
  GIT_CLEAN_FLAGS: -ffdx
  
  # Métadonnées pipeline
  PIPELINE_VERSION: "3.0.0"
  PIPELINE_TYPE: "modular"

# =============================================================================
# 📚 DOCUMENTATION DE LA STRUCTURE MODULAIRE
# =============================================================================
# 
# 🗂️ ORGANISATION DES MODULES :
# 
# 📄 variables.yml
#   - Variables globales (TF_VERSION, paths, etc.)
#   - Configuration cache optimisée
#   - Variables de performance
# 
# 📄 templates.yml
#   - Template .install_terraform
#   - Template .setup_ssh
#   - Templates par environnement (.dev_environment, .prod_environment)
# 
# 📄 terraform.yml
#   - Jobs validate_versions, validate
#   - Jobs plan_dev, plan_prod
#   - Jobs apply_dev, apply_prod
# 
# 📄 ansible.yml
#   - Jobs ansible_dev, ansible_prod
#   - Configuration inventaires
# 
# 📄 sync.yml
#   - Job mirror_to_github
#   - Job sync_issues_to_github
# 
# 📄 cleanup.yml
#   - Job cleanup
#   - Maintenance automatique
# 
# 📁 .gitlab/scripts/
#   - Scripts bash externalisés
#   - Logique métier modulaire
# 
# =============================================================================
# 🔧 MIGRATION ET ROLLBACK
# =============================================================================
# 
# Pour revenir à l'ancien pipeline en cas de problème :
# 1. Renommer .gitlab-ci.yml en .gitlab-ci.yml.modular
# 2. Renommer .gitlab-ci.yml.backup en .gitlab-ci.yml
# 3. Pusher le changement
# 
# Pour debug le nouveau pipeline :
# 1. Vérifier les includes avec GitLab CI Lint
# 2. Examiner les logs de chaque module séparément
# 3. Utiliser les variables de debug (set -x dans les scripts)
