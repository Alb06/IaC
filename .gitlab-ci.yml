stages:
  - validate
  - plan
  - apply
  - deploy
  - cleanup

variables:
  TF_ROOT: ${CI_PROJECT_DIR}/terraform/environments
  TF_VERSION: 1.12.1
  GIT_DEPTH: 0
  FORCE_MIRROR: "false"

# Cache des plugins Terraform
cache:
  paths:
    - .terraform

# Installation manuelle de Terraform
.install_terraform: &install_terraform
  before_script:
    - apk add --no-cache curl unzip bash
    - curl -SLO "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
    - unzip "terraform_${TF_VERSION}_linux_amd64.zip" -d /usr/local/bin/
    - chmod +x /usr/local/bin/terraform
    - terraform --version

# Validation du code Terraform
validate:
  stage: validate
  image: alpine:latest
  <<: *install_terraform
  script:
    - cd ${TF_ROOT}
    - |
      if [ ! -d "${ENV}" ]; then
        echo "Erreur: Le dossier ${ENV} n'existe pas dans ${TF_ROOT}"
        ls -la
        exit 1
      fi
    - find . -type f -name "*.tf" -exec dirname {} \; | sort -u | while read m; do (cd "$m" && terraform init -backend=false && terraform validate); done
  variables:
    ENV: dev
  tags:
    - terraform

# Planification des changements Terraform
plan:
  stage: plan
  image: alpine:latest
  <<: *install_terraform
  script:
    - cd ${TF_ROOT}/${ENV}
    - terraform init
    - terraform plan -out=tfplan
  variables:
    ENV: dev
  artifacts:
    paths:
      - ${TF_ROOT}/${ENV}/tfplan
    expire_in: 1 week
  tags:
    - terraform
  only:
    - merge_requests

# Application des changements Terraform
apply:
  stage: apply
  image: alpine:latest
  <<: *install_terraform
  script:
    - cd ${TF_ROOT}/${ENV}
    - terraform init
    - terraform apply -auto-approve tfplan
  variables:
    ENV: dev
  dependencies:
    - plan
  tags:
    - terraform
  only:
    - main
  when: manual

# Déploiement Ansible
ansible:
  stage: apply
  image: cytopia/ansible:latest
  script:
    - cd ${CI_PROJECT_DIR}/ansible
    - ansible-playbook -i inventory/dev playbooks/setup.yml
  tags:
    - ansible
  only:
    - main
  when: manual

# Déploiement Kubernetes avec Helm
kubernetes:
  stage: apply
  image: dtzar/helm-kubectl:latest
  script:
    - cd ${CI_PROJECT_DIR}/kubernetes/helm-charts
    - helm upgrade --install my-app ./my-app --namespace default
  tags:
    - kubernetes
  only:
    - main
  when: manual

# Synchronisation avec GitHub
mirror_to_github:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache git openssh
  script:
    # Configuration SSH
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519
    - chmod 600 ~/.ssh/id_ed25519
    - ssh-keyscan github.com >> ~/.ssh/known_hosts
    
    # Debugging
    - echo "=== État Git avant synchronisation ==="
    - git branch -a
    - git log --oneline -5
    - git remote -v
    
    # Configuration du remote GitHub
    - git remote remove mirror || true
    - git remote add mirror git@github.com:Alb06/IaC.git
    
    # CORRECTION : Mettre à jour la branche main locale avec origin/main
    - git checkout main
    - git reset --hard origin/main
    
    # Vérification de l'état après checkout
    - echo "=== État après checkout/reset ==="
    - git branch
    - git log --oneline -3
    
    # Synchronisation forcée du commit actuel
    - echo "=== Synchronisation vers GitHub ==="
    - git push mirror main --force
    
    # Vérification finale
    - echo "=== Vérification post-synchronisation ==="
    - git ls-remote mirror main
    
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
  tags:
    - terraform
  allow_failure: false

# Nettoyage (optionnel)
cleanup:
  stage: cleanup
  image: alpine:latest
  script:
    - echo "Nettoyage des ressources temporaires..."
  tags:
    - terraform
  when: manual