# =============================================================================
# PIPELINE GITLAB CI/CD - INFRASTRUCTURE AS CODE
# =============================================================================
# Description : Pipeline automatis√© pour le d√©ploiement IaC
# Utilise les variables centralis√©es du module globals
# =============================================================================

stages:
  - validate
  - plan
  - apply
  - deploy
  - cleanup

variables:
  TF_ROOT: ${CI_PROJECT_DIR}/terraform/environments
  # Versions r√©cup√©r√©es dynamiquement depuis les outputs Terraform
  TF_VERSION: "1.12.1"  # TODO: R√©cup√©rer depuis module globals
  GIT_DEPTH: 0
  # Configuration Ansible
  ANSIBLE_HOST_KEY_CHECKING: "False"
  ANSIBLE_FORCE_COLOR: "True"
  # Configuration s√©curit√©
  DOCKER_TLS_CERTDIR: "/certs"

# Cache optimis√© des plugins Terraform et d√©pendances
cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths:
    - .terraform
    - .terraform.lock.hcl
    - ${TF_ROOT}/**/.terraform
    - /tmp/terraform-cache

# =============================================================================
# TEMPLATES R√âUTILISABLES
# =============================================================================

.install_terraform: &install_terraform
  before_script:
    - echo "üîß Installation de Terraform v${TF_VERSION}..."
    - apk add --no-cache curl unzip bash git openssh
    - mkdir -p /tmp/terraform-cache
    - |
      if [ ! -f "/tmp/terraform-cache/terraform_${TF_VERSION}" ]; then
        echo "üì• T√©l√©chargement de Terraform..."
        curl -SLO "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
        unzip "terraform_${TF_VERSION}_linux_amd64.zip" -d /tmp/terraform-cache/
        mv /tmp/terraform-cache/terraform "/tmp/terraform-cache/terraform_${TF_VERSION}"
      fi
    - cp "/tmp/terraform-cache/terraform_${TF_VERSION}" /usr/local/bin/terraform
    - chmod +x /usr/local/bin/terraform
    - terraform --version
    - echo "‚úÖ Terraform install√© avec succ√®s"

.setup_ssh: &setup_ssh
  - echo "üîê Configuration SSH..."
  - mkdir -p ~/.ssh
  - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519
  - chmod 600 ~/.ssh/id_ed25519
  - ssh-keyscan -H github.com >> ~/.ssh/known_hosts
  - eval $(ssh-agent -s)
  - ssh-add ~/.ssh/id_ed25519

# =============================================================================
# VALIDATION ET PLANIFICATION
# =============================================================================

# Validation globale du code Terraform
validate:
  stage: validate
  image: alpine:latest
  <<: *install_terraform
  script:
    - echo "üîç Validation du code Terraform..."
    - cd ${TF_ROOT}
    
    # Validation du module globals
    - echo "üìã Validation du module globals..."
    - cd ../globals && terraform init -backend=false && terraform validate
    - cd ../environments
    
    # Validation de tous les environnements
    - |
      for env in dev prod; do
        echo "üìã Validation environnement: $env"
        if [ ! -d "$env" ]; then
          echo "‚ùå Dossier $env inexistant"
          exit 1
        fi
        cd "$env"
        terraform init -backend=false
        terraform validate
        if [ $? -eq 0 ]; then
          echo "‚úÖ $env valid√© avec succ√®s"
        else
          echo "‚ùå Erreur de validation pour $env"
          exit 1
        fi
        cd ..
      done
    - echo "üéâ Validation globale r√©ussie"
  
  # Execution sur tous les commits et MR
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
  tags:
    - terraform

# Planification pour l'environnement dev (VERSION CORRIG√âE)
plan_dev:
  stage: plan
  image: alpine:latest
  <<: *install_terraform
  variables:
    ENV: dev
  script:
    - echo "üìã Planification Terraform pour $ENV..."
    - cd ${TF_ROOT}/${ENV}
    - terraform init
    
    # R√©cup√©ration des variables depuis le module globals et planification
    - echo "üîç R√©cup√©ration des variables centralis√©es..."
    - |
      set +e  # D√©sactive l'arr√™t automatique sur erreur
      terraform plan -out=tfplan -detailed-exitcode
      plan_exit_code=$?
      set -e  # R√©active l'arr√™t automatique sur erreur
      
      echo "Terraform plan exit code: $plan_exit_code"
      
      case $plan_exit_code in
        0)
          echo "‚úÖ Aucun changement d√©tect√©"
          echo "PLAN_STATUS=no_changes" > ${CI_PROJECT_DIR}/plan_status_${ENV}.env
          plan_result="success"
          ;;
        1)
          echo "‚ùå Erreur lors de la planification"
          echo "PLAN_STATUS=error" > ${CI_PROJECT_DIR}/plan_status_${ENV}.env
          exit 1
          ;;
        2)
          echo "üìù Changements d√©tect√©s, plan g√©n√©r√©"
          echo "PLAN_STATUS=changes_detected" > ${CI_PROJECT_DIR}/plan_status_${ENV}.env
          plan_result="success"
          ;;
        *)
          echo "‚ùå Code de sortie inattendu: $plan_exit_code"
          echo "PLAN_STATUS=unknown_error" > ${CI_PROJECT_DIR}/plan_status_${ENV}.env
          exit 1
          ;;
      esac
      
      echo "Plan result: $plan_result"
    
    # Affichage r√©sum√© du plan
    - echo "üìä R√©sum√© du plan Terraform:"
    - terraform show -no-color tfplan | head -50
    
    # CORRECTION: Cr√©er le fichier plan_status.env dans le bon r√©pertoire
    - cp ${CI_PROJECT_DIR}/plan_status_${ENV}.env ./plan_status.env
    
    - echo "‚úÖ Planification $ENV termin√©e avec succ√®s"
    
  artifacts:
    paths:
      - ${TF_ROOT}/${ENV}/tfplan
      - ${TF_ROOT}/${ENV}/plan_status.env
    expire_in: 1 week
    reports:
      dotenv: ${TF_ROOT}/${ENV}/plan_status.env
  
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
  tags:
    - terraform

# Planification pour l'environnement prod (VERSION CORRIG√âE)
plan_prod:
  stage: plan
  image: alpine:latest
  <<: *install_terraform
  variables:
    ENV: prod
  script:
    - echo "üìã Planification Terraform pour $ENV..."
    - cd ${TF_ROOT}/${ENV}
    - terraform init
    
    # Validation suppl√©mentaire pour la production
    - echo "üîê Validations de s√©curit√© production..."
    - |
      # V√©rification des variables critiques
      if [ -z "$SSH_PRIVATE_KEY" ]; then
        echo "‚ùå SSH_PRIVATE_KEY manquante pour la production"
        exit 1
      fi
      
      set +e  # D√©sactive l'arr√™t automatique sur erreur
      terraform plan -out=tfplan -detailed-exitcode
      plan_exit_code=$?
      set -e  # R√©active l'arr√™t automatique sur erreur
      
      echo "Terraform plan exit code: $plan_exit_code"
      
      case $plan_exit_code in
        0)
          echo "‚úÖ Aucun changement d√©tect√© en production"
          echo "PLAN_STATUS=no_changes" > ${CI_PROJECT_DIR}/plan_status_${ENV}.env
          plan_result="success"
          ;;
        1)
          echo "‚ùå Erreur lors de la planification production"
          echo "PLAN_STATUS=error" > ${CI_PROJECT_DIR}/plan_status_${ENV}.env
          exit 1
          ;;
        2)
          echo "‚ö†Ô∏è  ATTENTION: Changements d√©tect√©s en PRODUCTION"
          echo "PLAN_STATUS=changes_detected" > ${CI_PROJECT_DIR}/plan_status_${ENV}.env
          terraform show -no-color tfplan
          plan_result="success"
          ;;
        *)
          echo "‚ùå Code de sortie inattendu: $plan_exit_code"
          echo "PLAN_STATUS=unknown_error" > ${CI_PROJECT_DIR}/plan_status_${ENV}.env
          exit 1
          ;;
      esac
      
      echo "Plan result: $plan_result"
    
    # Cr√©er le fichier plan_status.env dans le bon r√©pertoire
    - cp ${CI_PROJECT_DIR}/plan_status_${ENV}.env ./plan_status.env
    
    - echo "‚úÖ Planification $ENV termin√©e avec succ√®s"
  
  artifacts:
    paths:
      - ${TF_ROOT}/${ENV}/tfplan
      - ${TF_ROOT}/${ENV}/plan_status.env
    expire_in: 1 week
    reports:
      dotenv: ${TF_ROOT}/${ENV}/plan_status.env
  
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  tags:
    - terraform

# =============================================================================
# APPLICATION DES CHANGEMENTS
# =============================================================================

# Application en environnement dev
apply_dev:
  stage: apply
  image: alpine:latest
  <<: *install_terraform
  variables:
    ENV: dev
  script:
    - echo "üöÄ Application Terraform pour $ENV..."
    - cd ${TF_ROOT}/${ENV}
    - terraform init
    
    # V√©rification de l'existence du plan
    - |
      if [ ! -f "tfplan" ]; then
        echo "‚ùå Fichier plan non trouv√©"
        exit 1
      fi
    
    # Application du plan
    - terraform apply -auto-approve tfplan
    
    # R√©cup√©ration des outputs pour validation
    - echo "üìä R√©cup√©ration des outputs..."
    - terraform output -json > terraform_outputs.json
    
    # Validation des inventaires Ansible g√©n√©r√©s
    - echo "üîç Validation des inventaires Ansible..."
    - |
      inventory_file="../../../ansible/inventory/${ENV}"
      if [ -f "$inventory_file" ]; then
        echo "‚úÖ Inventaire g√©n√©r√©: $inventory_file"
        head -20 "$inventory_file"
      else
        echo "‚ùå Inventaire non g√©n√©r√©"
        exit 1
      fi
  
  artifacts:
    paths:
      - ${TF_ROOT}/${ENV}/terraform_outputs.json
      - ansible/inventory/${ENV}
    expire_in: 1 day
  
  dependencies:
    - plan_dev
  
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
      allow_failure: false
  tags:
    - terraform

# Application en environnement prod (protection renforc√©e)
apply_prod:
  stage: apply
  image: alpine:latest
  <<: *install_terraform
  variables:
    ENV: prod
  script:
    - echo "üöÄ Application Terraform pour PRODUCTION..."
    - echo "‚ö†Ô∏è  ATTENTION D√©ploiement en environnement de PRODUCTION"
    
    - cd ${TF_ROOT}/${ENV}
    - terraform init
    
    # V√©rifications de s√©curit√© renforc√©es
    - |
      echo "üîê V√©rifications de s√©curit√© production..."
      
      if [ ! -f "tfplan" ]; then
        echo "‚ùå Fichier plan non trouv√©"
        exit 1
      fi
      
      # V√©rification de la branche
      if [ "$CI_COMMIT_BRANCH" != "main" ]; then
        echo "‚ùå D√©ploiement production autoris√© uniquement depuis main"
        exit 1
      fi
      
      # V√©rification de l'auteur (optionnel)
      echo "üë§ D√©ploiement par: $GITLAB_USER_NAME ($GITLAB_USER_EMAIL)"
    
    # Sauvegarde avant application
    - echo "üíæ Sauvegarde de l'√©tat actuel..."
    - cp terraform.tfstate "terraform.tfstate.backup.$(date +%Y%m%d_%H%M%S)" 2>/dev/null || true
    
    # Application du plan
    - terraform apply -auto-approve tfplan
    
    # Validation post-d√©ploiement
    - echo "‚úÖ Validation post-d√©ploiement..."
    - terraform output -json > terraform_outputs.json
    
    # Test de connectivit√© (si possible)
    - |
      server_ip=$(terraform output -raw server_config | jq -r '.ip' 2>/dev/null || echo "")
      if [ ! -z "$server_ip" ]; then
        echo "üåê Test de connectivit√© vers $server_ip..."
        ping -c 3 "$server_ip" || echo "‚ö†Ô∏è  Serveur non accessible via ping"
      fi
  
  artifacts:
    paths:
      - ${TF_ROOT}/${ENV}/terraform_outputs.json
      - ${TF_ROOT}/${ENV}/terraform.tfstate.backup.*
      - ansible/inventory/${ENV}
    expire_in: 7 days
  
  dependencies:
    - plan_prod
  
  environment:
    name: production
    action: start
  
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
      allow_failure: false
  tags:
    - terraform

# =============================================================================
# D√âPLOIEMENT ANSIBLE
# =============================================================================

# D√©ploiement Ansible dev
ansible_dev:
  stage: deploy
  image: cytopia/ansible:latest
  variables:
    ENV: dev
  before_script:
    - echo "üîß Pr√©paration Ansible pour $ENV..."
    - apk add --no-cache jq
  script:
    - cd ${CI_PROJECT_DIR}/ansible
    
    # V√©rification de l'inventaire g√©n√©r√©
    - |
      inventory_file="inventory/${ENV}"
      if [ ! -f "$inventory_file" ]; then
        echo "‚ùå Inventaire $inventory_file non trouv√©"
        echo "Contenu du dossier inventory:"
        ls -la inventory/
        exit 1
      fi
      
      echo "‚úÖ Inventaire trouv√©: $inventory_file"
      echo "Contenu de l'inventaire:"
      cat "$inventory_file"
    
    # Test de connectivit√© Ansible
    - echo "üîç Test de connectivit√© Ansible..."
    - ansible all -i "inventory/${ENV}" -m ping || echo "‚ö†Ô∏è  Test ping √©chou√©"
    
    # Ex√©cution du playbook (si existe)
    - |
      if [ -f "playbooks/setup.yml" ]; then
        echo "üöÄ Ex√©cution du playbook setup..."
        ansible-playbook -i "inventory/${ENV}" playbooks/setup.yml --check --diff
      else
        echo "‚ÑπÔ∏è  Aucun playbook setup.yml trouv√©"
      fi
  
  dependencies:
    - apply_dev
  
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
  tags:
    - ansible

# =============================================================================
# SYNCHRONISATION ET NETTOYAGE
# =============================================================================

# Synchronisation vers GitHub
mirror_to_github:
  stage: deploy
  image: alpine:latest
  before_script:
    - *setup_ssh
  script:
    - echo "üîÑ Synchronisation vers GitHub..."
    - git remote add mirror git@github.com:Alb06/IaC.git || true
    - git push mirror HEAD:main --force
    - echo "‚úÖ Synchronisation termin√©e"
  
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
  tags:
    - terraform

# Synchronisation des issues (optionnel)
sync_issues_to_github:
  stage: deploy
  image: python:3.11
  timeout: 10m
  before_script:
    - pip install requests
  script:
    - echo "üîÑ Synchronisation des issues GitLab ‚Üí GitHub..."
    - python scripts/ci-cd/sync_issues.py
  
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
  tags:
    - terraform

# Nettoyage des ressources temporaires
cleanup:
  stage: cleanup
  image: alpine:latest
  script:
    - echo "üßπ Nettoyage des ressources temporaires..."
    - |
      # Nettoyage des anciens plans
      find ${TF_ROOT} -name "tfplan" -mtime +7 -delete || true
      find ${TF_ROOT} -name "*.backup.*" -mtime +30 -delete || true
      
      # Nettoyage des logs
      find /tmp -name "*.log" -mtime +1 -delete || true
      
      echo "‚úÖ Nettoyage termin√©"
  
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
  tags:
    - terraform